"use strict";(globalThis.webpackChunkdkmfzf_frontend_portfolio=globalThis.webpackChunkdkmfzf_frontend_portfolio||[]).push([[289],{23289:(n,o,e)=>{e.r(o),e.d(o,{PlasticSphere:()=>v,default:()=>f});var i=e(74848),t=e(96540),l=e(24922),r=e(2056);const a=()=>{const n=(0,t.useRef)(null);return(0,r.F)((({clock:o,camera:e})=>{n.current&&(n.current.uniforms.uTime.value=o.getElapsedTime(),n.current.uniforms.uViewDirection.value=e.position,n.current.uniforms.uGlowDirection.value=new l.Pq0(0,0,-1),n.current.uniforms.uGlowLength.value=5+2*Math.sin(o.elapsedTime))})),(0,i.jsx)("shaderMaterial",{ref:n,uniforms:{uTime:{value:0},uGlowColor:{value:new l.Pq0(.3,.6,1)},uGlowSize:{value:2},uGlowLength:{value:2},uGlowFalloff:{value:2},uViewDirection:{value:new l.Pq0},uGlowDirection:{value:new l.Pq0(0,0,-5)}},vertexShader:'#define GLSLIFY 1\nfloat PI = 3.14;\n\nvec3 smoothCos(vec3 dryFract)\n{\n  return cos(dryFract * PI);\n}\n\nvec3 cosInterpolation(vec3 noInterVector)\n{\n  return noInterVector * (-.5) + .5;\n}\n\n/*\n  Функция для создания псевдосучайного шума.\n  Она создаёт "плавный" 3D-шум (как облака или мраморная текстура)\n*/\nfloat smoothNoise3D(vec3 param) // на вход получаем точку в 3D пространстве (вершину)\n{\n  // сначала входная точка разделяется на целую часть\n  // было: (0.27, 1.24, 2.25)\n  // стало: (0, 1, 2)\n  vec3 integer = floor(param); // целая часть координаты куба, в котором находится точка\n  \n  // это значение нам нужно что бы расчитать интерапаляцию и сделать\n  // плавный переход между вершинами\n  vec3 dryFract = param - integer; // это вычисление дробной части вершины\n\n  // (param - integer) * acos(-1.) - эта операция даёт волну от 1 до -1\n  // так как у нас dryFract это дробное значение оно располагается от 0 до 1\n  // по этому умножение на PI даёт плавный результат казался ещё плавнее\n  // можно использовать косиносувую интерпаляцию -> было: [-1, 1] стало [0, 1]\n  vec3 smoothFract = cosInterpolation(smoothCos(dryFract)); // применяем функцию плавного интерполяционного ядра\n  \n  // создаём четыре псевдослучайных числа для вершин куба\n  // вычисления (например integer(2, 1, 0)):\n  // 1. dot(integer, vec3(1., 57., 21.)) -> 2*1 + 1*57 + 0*21 = 59;\n  // 2. 59 + vec4(0., 57., 21., 78.);\n  // функция dot выступает как хеш-функция, она даёт рандомный результат от значения integer\n  vec4 pseudorandomNumber = dot(integer, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.); // применяем сколярное (dot) произведение для базовго хеша\n  \n  // делаем линейную интерпаляцию значений\n  pseudorandomNumber = mix(\n    sin(cos(pseudorandomNumber) * pseudorandomNumber),\n    sin(cos(1. + pseudorandomNumber) * (1. + pseudorandomNumber)),\n    smoothFract.x\n  );\n\n  pseudorandomNumber.xy = mix(\n    pseudorandomNumber.xz,\n    pseudorandomNumber.yw,\n    smoothFract.y\n  );\n  \n  return mix(pseudorandomNumber.x, pseudorandomNumber.y, smoothFract.z);\n}\n\nfloat noiseCoordinateMult(\n  float positionAxis,\n  float indentAxis,\n  float clampMin,\n  float clampMax,\n  float coefficientRefraction\n) {\n  return clamp((positionAxis + indentAxis) * .5, clampMin, clampMax) * coefficientRefraction;\n}\n\nuniform float uTime;\nuniform vec3 uViewDirection;\nuniform vec3 uGlowDirection;\n\nvarying float vDisplacement;\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nvarying vec3 vViewDir;\nvarying vec3 vGlowDir;\n\nvoid main() {\n  vUv = uv;\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  \n  float coefficientRefraction = .1;\n  float indentAxis = 2.;\n  float clampMin = -1.;\n  float clampMax = 1.;\n  float speedAnimation = 0.25;\n  float displacementDitails = 1.;\n\n  float noiseMultX = noiseCoordinateMult(\n    position.x,\n    indentAxis,\n    clampMin,\n    clampMax,\n    coefficientRefraction\n  );\n  float noiseMultInvertX = noiseCoordinateMult(\n    -position.x,\n    indentAxis,\n    clampMin,\n    clampMax,\n    coefficientRefraction\n  );\n\n  float noiseMultPeak = noiseCoordinateMult(\n    position.x,\n    3.,\n    -1.,\n    1.,\n    .1\n  );\n  \n  float displacement = \n    (smoothNoise3D((position + uTime * speedAnimation) * displacementDitails + (cos(uTime * 2.) * .1)) * noiseMultX) +\n    (smoothNoise3D((position + uTime * speedAnimation) * displacementDitails + (cos(uTime * .1) * .1)) * noiseMultInvertX) +\n    (smoothNoise3D((position + uTime * speedAnimation) * displacementDitails + (cos(uTime * .1) * .1)) * noiseMultPeak);\n  \n  vDisplacement = displacement;\n  vec3 newPosition = position + normal * displacement;\n  vPosition = newPosition;\n\n  vViewDir = normalize(uViewDirection - vPosition);\n  vGlowDir = uGlowDirection;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n',fragmentShader:"#define GLSLIFY 1\n// idea: https://github.com/pavel-mazhuga/portfolio/blob/main/src/app/glsl-utils/palette.glsl\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.28318*(c*t+d));\n}\n\nuniform float uTime;\nuniform vec3 uGlowColor;\nuniform float uGlowSize;\n\nuniform float uGlowLength;\nuniform float uGlowFalloff;\n\nvarying float vDisplacement;\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nvarying vec3 vViewDir;\nvarying vec3 vGlowDir;\n\nvec3 yellowRedPurplePinkPalette(float t) {\n    vec3 color1 = vec3(1.0, 1.0, 0.0);\n    vec3 color2 = vec3(1.0, 0.0, 0.0);\n    vec3 color3 = vec3(0.5, 0.0, 1.0);\n    vec3 color4 = vec3(1.0, 0.5, 1.0);\n    \n    if (t < 0.33) {\n        return mix(color1, color2, t * 3.0);\n    } else if (t < 0.66) {\n        return mix(color2, color3, (t - 0.33) * 3.0);\n    } else {\n        return mix(color3, color4, (t - 0.66) * 3.0);\n    }\n}\n\nvec3 applyGlow(vec3 color, float intensity) {\n    float glow = smoothstep(0.0, uGlowSize, intensity);\n    float falloff = pow(glow, 10.0) * 5.0;\n    return mix(color, uGlowColor, falloff);\n}\n\nvoid main() {\n    vec2 uv = vUv;\n\n    vec3 color = \n        vec3((0.1 + length(vPosition.y * vDisplacement)) * 0.8\n        + vec3(pow(length(vDisplacement), 1.2)) * 7.);\n\n    // Используем новую палитру\n    float palettePos = clamp(color.z, 0.0, 1.0);\n    color = yellowRedPurplePinkPalette(palettePos) * 1.2;\n    \n    float glowIntensity = pow(vDisplacement, 1.5) * 5.0;\n    color = applyGlow(color, glowIntensity);\n    \n    float rim = 1.0 - abs(dot(normalize(vPosition), vec3(0.0, 0.0, 1.0)));\n    float rimGlow = pow(rim, 3.0) * 2.0;\n    color += uGlowColor * rimGlow;\n\n    float baseGlow = pow(vDisplacement, 2.0) * 2.0;\n    \n    float directionalGlow = dot(normalize(vPosition), vGlowDir);\n    directionalGlow = smoothstep(-1.0, 1.0, directionalGlow);\n    directionalGlow = pow(directionalGlow, uGlowFalloff) * uGlowLength;\n\n    float totalGlow = baseGlow + directionalGlow;\n\n    color += uGlowColor * totalGlow * 5.0;\n\n    gl_FragColor = vec4(color, 1.0);\n    #include <colorspace_fragment>\n}\n",toneMapped:!1,transparent:!0,opacity:.2,depthWrite:!1,blending:l.EZo})};var c=e(73560),s=e(3407),m=e(54698),u=e(94204);const v=({baseRadius:n=1.5})=>{const o=(0,t.useRef)(null);return(0,i.jsx)(t.Suspense,{fallback:(0,i.jsx)(s.Z,{}),children:(0,i.jsx)("div",{style:{width:"100vw",height:"100vh",position:"relative",backgroundColor:"black"},children:(0,i.jsxs)(c.Hl,{camera:{position:[0,0,10],fov:30},style:{filter:"blur(4px)"},children:[(0,i.jsx)("ambientLight",{intensity:1}),(0,i.jsxs)("mesh",{ref:o,children:[(0,i.jsx)("icosahedronGeometry",{args:[n,64]}),(0,i.jsx)(a,{})]}),(0,i.jsx)(m.s,{children:(0,i.jsx)(u.m,{intensity:1,luminanceThreshold:.5,luminanceSmoothing:1.5,height:300,kernelSize:5})})]})})})},f=v}}]);