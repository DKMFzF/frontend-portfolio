"use strict";(globalThis.webpackChunkdkmfzf_frontend_portfolio=globalThis.webpackChunkdkmfzf_frontend_portfolio||[]).push([[188],{4188:(e,n,t)=>{t.r(n),t.d(n,{default:()=>l});var o=t(74848),i=t(96540),r=t(24922),u=t(39437),s=t(17024);const l=()=>{const e=(0,i.useRef)(null);return(0,i.useEffect)((()=>{const n=new r.Z58,t=new r.ubm(75,window.innerWidth/window.innerHeight,.1,1e3);t.position.z=3;const o=new u.WebGLRenderer({antialias:!0});e.current&&(o.setSize(e.current.clientWidth,e.current.clientHeight),e.current.appendChild(o.domElement));const i=new s.N(t,o.domElement);i.enableZoom=!1,i.enablePan=!1;const l={u_time:{value:0},u_pulse:{value:0},u_mouse:{value:new r.I9Y(.5,.5)},u_resolution:{value:new r.I9Y(e.current?.clientWidth||window.innerWidth,e.current?.clientHeight||window.innerHeight)},u_spherePosition:{value:new r.Pq0}},a=new r.eaF(new r.Gu$(1,64,64),new r.BKk({uniforms:l,vertexShader:"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n  vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"precision highp float;\n#define GLSLIFY 1\nuniform float u_time;\nuniform float u_pulse;\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_spherePosition;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\n\n// Шумовые функции\nfloat noise(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat fbm(vec2 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  for (int i = 0; i < 5; i++) {\n    value += amplitude * noise(p);\n    p *= 2.0;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n\n// Основная функция рендеринга\nvoid main() {\n  vec2 uv = vUv - 0.5;\n  uv.x *= u_resolution.x / u_resolution.y;\n  \n  // Эффект глубины\n  float depth = dot(normalize(vNormal), vec3(0,0,1));\n  \n  // Динамические искажения\n  float pulseFactor = 0.1 * u_pulse;\n  uv += 0.1 * sin(u_time + uv.yx * 5.0) * (1.0 + pulseFactor);\n  \n  // Ядро энергии\n  float radius = length(uv);\n  float angle = atan(uv.y, uv.x);\n  float n = fbm(uv * 3.0 + u_time * 0.5);\n  \n  float core = smoothstep(0.3 + pulseFactor*0.1, 0.0, radius - n*0.1);\n  float glow = exp(-radius * (4.0 + pulseFactor*2.0));\n  \n  // Цветовые градиенты\n  vec3 colorGradient = mix(\n    vec3(1.0, 0.2, 0.0),\n    vec3(0.0, 0.5, 1.0),\n    vUv.y + 0.2*sin(u_time*0.5)\n  );\n  \n  // Световые лучи\n  float rays = sin(angle*10.0 + u_time*2.0) * 0.1;\n  float rayEffect = smoothstep(0.2, 0.0, abs(rays - radius)) * (0.8 + 0.2*depth);\n  \n  // Эффект от мыши - основная сторона\n  vec2 mouseUV = vec2(u_mouse.x, 1.0 - u_mouse.y);\n  float mouseDist = distance(vUv, mouseUV);\n  float mouseEffect = smoothstep(0.3, 0.0, mouseDist) * 0.5;\n  \n  // Эффект от мыши - противоположная сторона\n  vec2 oppositeMouseUV = vec2(1.0 - u_mouse.x, u_mouse.y);\n  float oppositeDist = distance(vUv, oppositeMouseUV);\n  float oppositeEffect = smoothstep(0.4, 0.0, oppositeDist) * 0.3;\n  \n  // Собираем все эффекты\n  vec3 color = vec3(0.0);\n  color += core * colorGradient * (1.0 + pulseFactor);\n  color += glow * vec3(1.0, 0.5, 0.8);\n  color += rayEffect * vec3(1.0, 0.8, 0.5);\n  color += mouseEffect * vec3(1.0, 0.8, 0.2);\n  color += oppositeEffect * vec3(0.8, 0.9, 1.0);\n  \n  gl_FragColor = vec4(color, 1.0);\n}\n",side:r.$EB}));let c;n.add(a);let v=0,m=1;const d=()=>{l.u_time.value+=.01,v+=.01*m,(v>1||v<0)&&(m*=-1),l.u_pulse.value=v,l.u_spherePosition.value.copy(a.position),i.update(),o.render(n,t),c=requestAnimationFrame(d)};d();const p=()=>{e.current&&(t.aspect=e.current.clientWidth/e.current.clientHeight,t.updateProjectionMatrix(),o.setSize(e.current.clientWidth,e.current.clientHeight),l.u_resolution.value.set(e.current.clientWidth,e.current.clientHeight))},f=n=>{if(e.current){const t=e.current.getBoundingClientRect();l.u_mouse.value.x=(n.clientX-t.left)/t.width,l.u_mouse.value.y=(n.clientY-t.top)/t.height}};return window.addEventListener("resize",p),e.current?.addEventListener("mousemove",f),()=>{cancelAnimationFrame(c),window.removeEventListener("resize",p),e.current?.removeEventListener("mousemove",f),e.current&&e.current.contains(o.domElement)&&e.current.removeChild(o.domElement),i.dispose()}}),[]),(0,o.jsx)("div",{ref:e,style:{width:"100%",height:"100%",position:"absolute",top:0,left:0}})}}}]);